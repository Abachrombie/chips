<h1 id="new-opcodes">New Opcodes</h1>

<h2 id="scaffolding-and-notation">Scaffolding and notation</h2>

<p>When Chia scripts are hashed it’s with a Merkle root to support only revealing the parts of the script which get executed. This is enabled by the removal of OP_IF, OP_ELSE and OP_ENDIF in favor of OP_IFJUMP, OP_IFNJUMP and OP_JUMP which don’t requiring parsing the entire script to execute.</p>

<p>When full nodes validate scripts they do some level of canonicalization by removing items from the stack which were unnecessary, changing elements to zero length which are unreferenced, and canonicalizing elements to their minimum length representation as bools or ints if that’s their only use.</p>

<p>Bigendian <code class="highlighter-rouge">n</code> is specified by the bytes after the opcode as follows
– length encoding: 0 - 127 verbatim
– leading 10 is a two byte encoding
– leading 110 is a threebyte encoding
– leading 1110 is a four byte encoding</p>

<p>In Chia Script you need to put an OP_VERIFY at the end because of the concept of Abort+Success. Chia CANNOT support tailcall semantics or anything that evaluates stack items as Script.</p>

<p>Chia does not use scriptSigs. Your signature is a stack. There’s no opcodes in the signatures.</p>

<p>In Chia script if the execution point gets past the end of the script it succeeds regardless of what’s currently on the stack or whether it got their via a jump</p>

<p>Integers are still little-endian and have a sign bit, but their valid range is expanded to allow for numbers between -2^63 and 2^63 non-inclusive. Overflows cause immediate abort fails.</p>

<h2 id="new-opcodes-1">New Opcodes</h2>

<p>New opcodes are taken out of the set of disabled Bitcoin opcodes. Later ones will be taken out of Bitcoin reserved opcodes followed by Bitcoin opcodes which were reclaimed in Chia script.</p>

<h4 id="op_ifjump">OP_IFJUMP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Consumes 1 stack item. if true, jump forward `n` bytes.
</code></pre></div></div>

<h4 id="op_ifnjump">OP_IFNJUMP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Consumes 1 stack item. if  not true, jump forward `n` bytes
</code></pre></div></div>

<h4 id="op_jump">OP_JUMP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Doesn't consume. Just jumps
</code></pre></div></div>

<h4 id="op_pull--op_pickbutbetter">OP_PULL – OP_PICKBUTBETTER</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interpret next `n` bytes as index from top of stack
copy item at index to top of stack
</code></pre></div></div>

<h4 id="op_dereference">OP_DEREFERENCE</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interpret next `n` bytes as index from bottom of stack
copy item at index to top of stack
</code></pre></div></div>

<h4 id="op_and--op_boolandbutbetter">OP_AND – OP_BOOLANDBUTBETTER</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>does AND with normal coercion rules
</code></pre></div></div>

<h4 id="op_or--op_boolorbutbetter">OP_OR – OP_BOOLORBUTBETTER</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>does OR with normal coercion rules
</code></pre></div></div>

<h4 id="op_abortsuccess">OP_ABORTSUCCESS</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>does what it says on the tin.
Reserved non-changing.
other opcodes will implement this feature, for soft-fork compatibility.
</code></pre></div></div>

<h4 id="op_cltvdrop">OP_CLTVDROP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>As CLTV, but consumes argument. (MAY BE REPLACED BY CHIP011)
</code></pre></div></div>

<h4 id="op_csvdrop">OP_CSVDROP</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AS CSV, but consumes argument. (MAY BE REPLACED BY CHIP011)
</code></pre></div></div>

<h4 id="op_blsaggregate">OP_BLSAGGREGATE</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>see chip006
</code></pre></div></div>

<h4 id="op_blsaggregatefromstack">OP_BLSAGGREGATEFROMSTACK</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>see chip006
</code></pre></div></div>

<h2 id="preserved-opcodes">Preserved Opcodes</h2>

<p>These are opcodes which we have decided of worthy of keeping verbatim from Bitcoin script. All others are changed to abort success.</p>

<h4 id="op_pushdata1">OP_PUSHDATA1</h4>

<p>The vast range of opcodes for specific amounts of pushes are removed in favor of this saner approach</p>

<h4 id="op_pushdata2">OP_PUSHDATA2</h4>

<p>This is kept despite have a not typical for Chia script length encoding because strings can’t be longer than 520 bytes anyway</p>

<h4 id="op_nop">OP_NOP</h4>

<p>Necessary to keep the blessed nop because everything else is turning into abort success</p>

<h4 id="op_verify">OP_VERIFY</h4>

<p>Tell me it’s true</p>

<h4 id="op_return">OP_RETURN</h4>

<p>Keeps its meaning of ‘abort fail’</p>

<h4 id="op_depth">OP_DEPTH</h4>

<p>Still useful for optional arguments</p>

<h4 id="op_drop">OP_DROP</h4>

<p>The only stack manipulation opcode to survive in its original form</p>

<h4 id="op_size">OP_SIZE</h4>

<p>Totally sane</p>

<h4 id="op_equal">OP_EQUAL</h4>

<p>Maybe this will be removed in favor of a OP_NOTEQUALVERIFY</p>

<h4 id="op_equalverify">OP_EQUALVERIFY</h4>

<p>Useful for comparing hashes</p>

<h4 id="op_negate">OP_NEGATE</h4>

<p>Normal math</p>

<h4 id="op_abs">OP_ABS</h4>

<p>Normal math</p>

<h4 id="not">not</h4>

<p>Necessary for multi-input boolean operators</p>

<h4 id="op_0notequal-aka-op_bool">OP_0NOTEQUAL aka OP_BOOL</h4>

<p>Coerces to a bool</p>

<h4 id="op_add">OP_ADD</h4>

<p>Normal math. Overflows now cause immediate abort failure</p>

<h4 id="op_sub">OP_SUB</h4>

<p>Normal math. Overflows now cause immediate abort failure</p>

<h4 id="op_numequal">OP_NUMEQUAL</h4>

<p>Normal math</p>

<h4 id="op_numequalverify">OP_NUMEQUALVERIFY</h4>

<p>The common case</p>

<h4 id="op_numnotequal">OP_NUMNOTEQUAL</h4>

<p>Normal math</p>

<h4 id="op_lessthan">OP_LESSTHAN</h4>

<p>Normal math</p>

<h4 id="op_greaterthan">OP_GREATERTHAN</h4>

<p>Normal math</p>

<h4 id="op_lessthanorequal">OP_LESSTHANOREQUAL</h4>

<p>Normal math</p>

<h4 id="op_greaterthanorequal">OP_GREATERTHANOREQUAL</h4>

<p>Normal math</p>

<h4 id="op_min">OP_MIN</h4>

<p>Normal math</p>

<h4 id="op_max">OP_MAX</h4>

<p>Normal math</p>

<h4 id="op_within">OP_WITHIN</h4>

<p>Normal math</p>

<h4 id="op_sha256">OP_SHA256</h4>

<p>It’s tempting to switch some things to a different hash function but better to stick with a single one for simplicity. The double version is removed with much prejudice.</p>

<h4 id="op_toaltstack">OP_TOALTSTACK</h4>

<p>As Bitcoin</p>

<h4 id="op_fromaltstack">OP_FROMALTSTACK</h4>

<p>As Bitcoin</p>
