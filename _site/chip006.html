<h1 id="cross-input-bls-aggregation">Cross-input BLS Aggregation</h1>

<h2 id="abstract">Abstract</h2>

<h2 id="motivation">Motivation</h2>

<p>Signatures take up a large portion of each block. Most Bitcoin transactions contain at least on signature. Bitcoinâ€™s serialized ECDSA signatures are approximately 65 bytes. As such, signatures are a non-trivial amount of storage and transmission overhead. BLS signatures are shorter than ECDSA signatures, and support signature aggregation, in which multiple signatures are combined and can be represented as a single signature.</p>

<h2 id="specification">Specification</h2>

<p>ECDSA signatures are disabled. This includes <code class="highlighter-rouge">OP_CHECKSIG</code>, <code class="highlighter-rouge">OP_CHECKSIGVERIFY</code>, <code class="highlighter-rouge">OP_CHECKMULTISIG</code>, and <code class="highlighter-rouge">OP_CHECKMULTISIGVERIFY</code>.</p>

<p>Signatures in witnesses/witness infos are aggregate across the transaction into a single signature. A new opcode to support this is introduced: <code class="highlighter-rouge">OP_BLSAGGREGATE</code>. This opcode adds pubkeys and messages to an aggregate signature verification staging area. This area enforces that messages cannot repeat.</p>

<p>When executing scripts, <code class="highlighter-rouge">OP_BLSAGGREGATE</code> pops one argument from the stack. These MUST be the BLS pubkey. <code class="highlighter-rouge">OP_BLSAGGREGATE</code> causes script execution to fail if the pubkey is malformed. The B12-381 pairing of the signed message (the SHA256 hash of the witness info mapped onto an element of g_1) and the pubkey is computed immediately and cached in the transaction aggregator.</p>

<p>The computational cost of <code class="highlighter-rouge">OP_BLSAGGREGATE</code> is one pairing for the first pubkey, plus one pairing and one g_t multiplication for each additional pubkey.</p>

<p><code class="highlighter-rouge">OP_BLSAGGREGATEFROMSTACK</code> works similarly. It takes two arguments: a message hash mapped to an elliptic curve point and a pubkey.</p>

<p>The aggregator keeps a set of messages, to ensure uniqueness. After all scripts have been executed, the aggregate signature is paired with the generator point of g_2, and the result is compared to the cached aggregate message/pubkey pairing. If they are not equal, transaction validation fails.</p>
